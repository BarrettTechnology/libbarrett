<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Message pipe services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Message pipe services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Message pipe services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__pipe.png" border="0" alt="" usemap="#group____pipe_map">
<map name="group____pipe_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,5,160,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Message pipe services.<p>
A message pipe is a two-way communication channel between Xenomai tasks and standard Linux processes using regular file I/O operations on a pseudo-device. Pipes can be operated in a message-oriented fashion so that message boundaries are preserved, and also in byte streaming mode from real-time to standard Linux processes for optimal throughput.<p>
Xenomai tasks open their side of the pipe using the <a class="el" href="group__pipe.html#g29521cc898afa0069963964955167aa5">rt_pipe_create()</a> service; standard Linux processes do the same by opening one of the /dev/rtpN special devices, where N is the minor number agreed upon between both ends of each pipe. Additionally, named pipes are available through the registry support, which automatically creates a symbolic link from entries under /proc/xenomai/registry/native/pipes/ to the corresponding special device file. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2pipe_8c.html">pipe.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g29521cc898afa0069963964955167aa5">rt_pipe_create</a> (RT_PIPE *pipe, const char *name, int minor, size_t poolsize)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g1d84976a1b9b668366261ca9b836b677">rt_pipe_delete</a> (RT_PIPE *pipe)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive</a> (RT_PIPE *pipe, RT_PIPE_MSG **msgp, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read</a> (RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send</a> (RT_PIPE *pipe, RT_PIPE_MSG *msg, size_t size, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write</a> (RT_PIPE *pipe, const void *buf, size_t size, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gd8edc920499d2c5c5d821ee7b9fa2bcd">rt_pipe_stream</a> (RT_PIPE *pipe, const void *buf, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_PIPE_MSG *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc</a> (RT_PIPE *pipe, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#g8face1c57df99cf43b029b3e3b6a05c6">rt_pipe_free</a> (RT_PIPE *pipe, RT_PIPE_MSG *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pipe.html#gb4d85ecda7675a75611500070c28b22e">rt_pipe_flush</a> (RT_PIPE *pipe, int mode)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g40f294bf6254d2e1b66b8b6b400fc2e5"></a><!-- doxytag: member="pipe.c::rt_pipe_alloc" ref="g40f294bf6254d2e1b66b8b6b400fc2e5" args="(RT_PIPE *pipe, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_PIPE_MSG* rt_pipe_alloc           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a message pipe buffer.<p>
This service allocates a message buffer from the pipe's heap which can be subsequently filled by the caller then passed to <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a> for sending. The beginning of the available data area of <em>size</em> contiguous bytes is accessible from P_MSGPTR(msg).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size in bytes of the buffer. This value should represent the size of the payload data.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address of the allocated message buffer upon success, or NULL if the allocation fails.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g29521cc898afa0069963964955167aa5"></a><!-- doxytag: member="pipe.c::rt_pipe_create" ref="g29521cc898afa0069963964955167aa5" args="(RT_PIPE *pipe, const char *name, int minor, size_t poolsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_create           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>poolsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a message pipe.<p>
This service opens a bi-directional communication channel allowing data exchange between Xenomai tasks and standard Linux processes. Pipes natively preserve message boundaries, but can also be used in byte stream mode from Xenomai tasks to standard Linux processes.<p>
<a class="el" href="group__pipe.html#g29521cc898afa0069963964955167aa5">rt_pipe_create()</a> always returns immediately, even if no Linux process has opened the associated special device file yet. On the contrary, the non real-time side could block upon attempt to open the special device file until <a class="el" href="group__pipe.html#g29521cc898afa0069963964955167aa5">rt_pipe_create()</a> is issued on the same pipe from a Xenomai task, unless O_NONBLOCK has been specified to the open(2) system call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The address of a pipe descriptor Xenomai will use to store the pipe-related data. This descriptor must always be valid while the pipe is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the message pipe. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created pipe.</td></tr>
  </table>
</dl>
Named pipes are supported through the use of the registry. When the registry support is enabled, passing a valid <em>name</em> parameter when creating a message pipe subsequently allows standard Linux processes to follow a symbolic link from /proc/xenomai/registry/pipes/<em>name</em> in order to reach the associated special device (i.e. /dev/rtp*), so that the specific <em>minor</em> information does not need to be known from those processes for opening the proper device file. In such a case, both sides of the pipe only need to agree upon a symbolic name to refer to the same data path, which is especially useful whenever the <em>minor</em> number is picked up dynamically using an adaptive algorithm, such as passing P_MINOR_AUTO as <em>minor</em> value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>The minor number of the device associated with the pipe. Passing P_MINOR_AUTO causes the minor number to be auto-allocated. In such a case, the <em>name</em> parameter must be valid so that user-space processes may subsequently follow the symbolic link that will be automatically created from /proc/xenomai/registry/pipes/<em>name</em> to the allocated pipe device entry (i.e. /dev/rtp*).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poolsize</em>&nbsp;</td><td>Specifies the size of a dedicated buffer pool for the pipe. Passing 0 means that all message allocations for this pipe are performed on the system heap.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the pipe, or if not enough memory could be obtained from the selected buffer pool for allocating the internal streaming buffer.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-ENODEV is returned if <em>minor</em> is different from P_MINOR_AUTO and is not a valid minor number for the pipe special device either (i.e. /dev/rtp*).</li></ul>
<p>
<ul>
<li>-EBUSY is returned if <em>minor</em> is already open.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g1d84976a1b9b668366261ca9b836b677"></a><!-- doxytag: member="pipe.c::rt_pipe_delete" ref="g1d84976a1b9b668366261ca9b836b677" args="(RT_PIPE *pipe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a message pipe.<p>
This service deletes a pipe previously created by <a class="el" href="group__pipe.html#g29521cc898afa0069963964955167aa5">rt_pipe_create()</a>. Data pending for transmission to non real-time processes are lost.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF can be returned if <em>pipe</em> is scrambled.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gb4d85ecda7675a75611500070c28b22e"></a><!-- doxytag: member="pipe.c::rt_pipe_flush" ref="gb4d85ecda7675a75611500070c28b22e" args="(RT_PIPE *pipe, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_flush           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the i/o queues associated with the kernel endpoint of a message pipe.<p>
This service flushes all data pending for consumption by the remote side in user-space for the given message pipe. Upon success, no data remains to be read from the remote side of the connection.<p>
The user-space equivalent is a call to: ioctl(pipefd, XNPIPEIOC_FLUSH, 0).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to flush.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A mask indicating which queues need to be flushed; the following flags may be combined in a single flush request:</td></tr>
  </table>
</dl>
<ul>
<li>XNPIPE_IFLUSH causes the input queue to be flushed (i.e. data coming from user-space to the kernel endpoint will be discarded).</li></ul>
<p>
<ul>
<li>XNPIPE_OFLUSH causes the output queue to be flushed (i.e. data going to user-space from the kernel endpoint will be discarded).</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g8face1c57df99cf43b029b3e3b6a05c6"></a><!-- doxytag: member="pipe.c::rt_pipe_free" ref="g8face1c57df99cf43b029b3e3b6a05c6" args="(RT_PIPE *pipe, RT_PIPE_MSG *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_free           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a message pipe buffer.<p>
This service releases a message buffer returned by <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> to the pipe's heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the affected pipe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>The address of the message buffer to free.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>msg</em> is not a valid message buffer previously allocated by the <a class="el" href="group__pipe.html#g40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc()</a> service.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g62cb64807c2c843f8e8eebb2dc3a7d4e"></a><!-- doxytag: member="pipe.c::rt_pipe_read" ref="g62cb64807c2c843f8e8eebb2dc3a7d4e" args="(RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_read           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a message from a pipe.<p>
This service retrieves the next message written to the associated special device in user-space. <a class="el" href="group__pipe.html#g62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a> always preserves message boundaries, which means that all data sent through the same write(2) operation to the special device will be gathered in a single message by this service. This services differs from <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> in that it copies back the payload data to a user-defined memory area, instead of returning a pointer to the internal message buffer holding such data.<p>
Unless otherwise specified, the caller is blocked for a given amount of time if no data is immediately available on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the read message contents.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The count of bytes from the received message to read up into <em>buf</em>. If <em>size</em> is lower than the actual message size, -ENOBUFS is returned since the incompletely received message would be lost. If <em>size</em> is zero, this call returns immediately with no other action.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some data is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no data is available on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of read bytes copied to the <em>buf</em> is returned upon success. Otherwise:</dd></dl>
<ul>
<li>0 is returned if the peer closed the channel while <a class="el" href="group__pipe.html#g62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a> was reading from it. There is no way to distinguish this situation from an empty message return using <a class="el" href="group__pipe.html#g62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a>. One should rather call <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> whenever this information is required.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no data is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no data is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
<ul>
<li>-ENOBUFS is returned if <em>size</em> is not large enough to collect the message data.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g731e5ef18007dcd58a9346bea66abbc6"></a><!-- doxytag: member="pipe.c::rt_pipe_receive" ref="g731e5ef18007dcd58a9346bea66abbc6" args="(RT_PIPE *pipe, RT_PIPE_MSG **msgp, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_receive           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG **&nbsp;</td>
          <td class="paramname"> <em>msgp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a message from a pipe.<p>
This service retrieves the next message written to the associated special device in user-space. <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> always preserves message boundaries, which means that all data sent through the same write(2) operation to the special device will be gathered in a single message by this service. This service differs from <a class="el" href="group__pipe.html#g62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a> in that it returns a pointer to the internal buffer holding the message, which improves performances by saving a data copy to a user-provided buffer, especially when large messages are involved.<p>
Unless otherwise specified, the caller is blocked for a given amount of time if no data is immediately available on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to receive from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msgp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the received message. Once consumed, the message space should be freed using <a class="el" href="group__pipe.html#g8face1c57df99cf43b029b3e3b6a05c6">rt_pipe_free()</a>. The application code can retrieve the actual data and size carried by the message by respectively using the P_MSGPTR() and P_MSGSIZE() macros. *msgp is set to NULL and zero is returned to the caller, in case the peer closed the channel while <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> was reading from it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some data is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no data is available on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of read bytes available from the received message is returned upon success; this value will be equal to P_MSGSIZE(*msgp). Otherwise:</dd></dl>
<ul>
<li>0 is returned and *msgp is set to NULL if the peer closed the channel while <a class="el" href="group__pipe.html#g731e5ef18007dcd58a9346bea66abbc6">rt_pipe_receive()</a> was reading from it. This is to be distinguished from an empty message return, where *msgp points to a valid - albeit empty - message block (i.e. P_MSGSIZE(*msgp) == 0).</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> was closed while reading.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no data is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no data is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf40b20cad1dcd7bedcda72beaa16c057"></a><!-- doxytag: member="pipe.c::rt_pipe_send" ref="gf40b20cad1dcd7bedcda72beaa16c057" args="(RT_PIPE *pipe, RT_PIPE_MSG *msg, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_send           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_PIPE_MSG *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message through a pipe.<p>
This service writes a complete message to be received from the associated special device. <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation from the special device. This service differs from <a class="el" href="group__pipe.html#g12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a> in that it accepts a canned message buffer, instead of a pointer to the raw data to be sent. This call is useful whenever the caller wants to prepare the message contents separately from its sending, which does not require to have all the data to be sent available at once but allows for incremental updates of the message, and also saves a message copy, since <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a> deals internally with message buffers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to send to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>The address of the message to be sent. The message space must have been allocated using the <a class="el" href="group__pipe.html#g40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc()</a> service. Once passed to <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a>, the memory pointed to by <em>msg</em> is no more under the control of the application code and thus should not be referenced by it anymore; deallocation of this memory will be automatically handled as needed. As a special exception, <em>msg</em> can be NULL and will not be dereferenced if <em>size</em> is zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message (payload data only). Zero is a valid value, in which case the service returns immediately without sending any message. This parameter allows you to actually send less data than you reserved using the <a class="el" href="group__pipe.html#g40f294bf6254d2e1b66b8b6b400fc2e5">rt_pipe_alloc()</a> service, which may be the case if you did not know how much space you needed at the time of allocation. In all other cases it may be more convenient to just pass P_MSGSIZE(msg).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>P_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li></ul>
<p>
<ul>
<li>P_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Upon success, this service returns <em>size</em>. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EPIPE is returned if the associated special device is not yet open.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gd8edc920499d2c5c5d821ee7b9fa2bcd"></a><!-- doxytag: member="pipe.c::rt_pipe_stream" ref="gd8edc920499d2c5c5d821ee7b9fa2bcd" args="(RT_PIPE *pipe, const void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_stream           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream bytes to a pipe.<p>
This service writes a sequence of bytes to be received from the associated special device. Unlike <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a>, this service does not preserve message boundaries. Instead, an internal buffer is filled on the fly with the data, which will be consumed as soon as the receiver wakes up.<p>
Data buffers sent by the <a class="el" href="group__pipe.html#gd8edc920499d2c5c5d821ee7b9fa2bcd">rt_pipe_stream()</a> service are always transmitted in FIFO order (i.e. P_NORMAL mode).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the buffer. Zero is a valid value, in which case the service returns immediately without buffering any data.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent upon success; this value may be lower than <em>size</em>, depending on the available space in the internal buffer. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EPIPE is returned if the associated special device is not yet open.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if the byte streaming mode has been disabled at configuration time by nullifying the size of the pipe buffer (see CONFIG_XENO_OPT_NATIVE_PIPE_BUFSZ).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g12f801963d0db6aa60bc6cf92f65697a"></a><!-- doxytag: member="pipe.c::rt_pipe_write" ref="g12f801963d0db6aa60bc6cf92f65697a" args="(RT_PIPE *pipe, const void *buf, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_write           </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&nbsp;</td>
          <td class="paramname"> <em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a message to a pipe.<p>
This service writes a complete message to be received from the associated special device. <a class="el" href="group__pipe.html#g12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation from the special device. This service differs from <a class="el" href="group__pipe.html#gf40b20cad1dcd7bedcda72beaa16c057">rt_pipe_send()</a> in that it accepts a pointer to the raw data to be sent, instead of a canned message buffer. This call is useful whenever the caller does not need to prepare the message contents separately from its sending.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pipe</em>&nbsp;</td><td>The descriptor address of the pipe to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message (payload data only). Zero is a valid value, in which case the service returns immediately without sending any message.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>P_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li></ul>
<p>
<ul>
<li>P_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Upon success, this service returns <em>size</em>. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a pipe descriptor.</li></ul>
<p>
<ul>
<li>-EPIPE is returned if the associated special device is not yet open.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough buffer space is available to complete the operation.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li></ul>
<p>
<ul>
<li>-ENODEV or -EBADF are returned if <em>pipe</em> is scrambled.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 11 12:33:53 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
