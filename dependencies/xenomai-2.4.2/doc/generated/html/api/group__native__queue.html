<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Message queue services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Message queue services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Message queue services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__native__queue.png" border="0" alt="" usemap="#group____native____queue_map">
<map name="group____native____queue_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,5,160,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Queue services.<p>
Message queueing is a method by which real-time tasks can exchange or pass data through a Xenomai-managed queue of messages. Messages can vary in length and be assigned different types or usages. A message queue can be created by one task and used by multiple tasks that send and/or receive messages to the queue.<p>
This implementation is based on a zero-copy scheme for message buffers. Message buffer pools are built over the nucleus's heap objects, which in turn provide the needed support for exchanging messages between kernel and user-space using direct memory mapping. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2queue_8c.html">queue.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#gacad717bbd6d75338fada8f5b4a67b3f">rt_queue_create</a> (RT_QUEUE *q, const char *name, size_t poolsize, size_t qlimit, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#gbc678dfb236b0dad434067496cead127">rt_queue_delete</a> (RT_QUEUE *q)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g8eaee8ca7d0c3af801c4df6f0adae421">rt_queue_alloc</a> (RT_QUEUE *q, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g40d16a5ab14ea033889bb839967204e4">rt_queue_free</a> (RT_QUEUE *q, void *buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send</a> (RT_QUEUE *q, void *mbuf, size_t size, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g9ef8d1826bb13fe706a4566890972657">rt_queue_write</a> (RT_QUEUE *q, const void *buf, size_t size, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g44759168a589ddbb2b60c1c1b183f448">rt_queue_receive</a> (RT_QUEUE *q, void **bufp, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g4083beec0186ce66c66ee0d3fc1b5eee">rt_queue_read</a> (RT_QUEUE *q, void *buf, size_t size, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g654017c0f87d8c23329aeefff93e6a70">rt_queue_inquire</a> (RT_QUEUE *q, RT_QUEUE_INFO *info)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g162bb372c5c3616666e8e1fbdcc79343">rt_queue_bind</a> (RT_QUEUE *q, const char *name, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__queue.html#g1f190858ca18d906db339e086bfa8ced">rt_queue_unbind</a> (RT_QUEUE *q)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g8eaee8ca7d0c3af801c4df6f0adae421"></a><!-- doxytag: member="queue.c::rt_queue_alloc" ref="g8eaee8ca7d0c3af801c4df6f0adae421" args="(RT_QUEUE *q, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rt_queue_alloc           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a message queue buffer.<p>
This service allocates a message buffer from the queue's internal pool which can be subsequently filled by the caller then passed to <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a> for sending.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the affected queue.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size in bytes of the buffer. Zero is an acceptable value, meaning that the message will not carry any payload data; the receiver will thus receive a zero-sized message.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address of the allocated message buffer upon success, or NULL if the allocation fails.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g162bb372c5c3616666e8e1fbdcc79343"></a><!-- doxytag: member="queue.c::rt_queue_bind" ref="g162bb372c5c3616666e8e1fbdcc79343" args="(RT_QUEUE *q, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to a shared message queue.<p>
This user-space only service retrieves the uniform descriptor of a given shared Xenomai message queue identified by its symbolic name. If the queue does not exist on entry, this service blocks the caller until a queue of the given name is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the queue to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The address of a queue descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>q</em> or <em>name</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked). This error may also be returned whenever the call attempts to bind from a user-space application to a local queue defined from kernel space (i.e. Q_SHARED was not passed to <a class="el" href="group__native__queue.html#gacad717bbd6d75338fada8f5b4a67b3f">rt_queue_create()</a>).</li></ul>
<p>
<ul>
<li>-ENOENT is returned if the special file /dev/rtheap (character-mode, major 10, minor 254) is not available from the filesystem. This device is needed to map the memory pool used by the shared queue into the caller's address space. udev-based systems should not need manual creation of such device entry.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="msg__queue_8c-example.html#a0">msg_queue.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gacad717bbd6d75338fada8f5b4a67b3f"></a><!-- doxytag: member="queue.c::rt_queue_create" ref="gacad717bbd6d75338fada8f5b4a67b3f" args="(RT_QUEUE *q, const char *name, size_t poolsize, size_t qlimit, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_create           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>poolsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>qlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a message queue.<p>
Create a message queue object that allows multiple tasks to exchange data through the use of variable-sized messages. A message queue is created empty. Message queues can be local to the kernel space, or shared between kernel and user-space.<p>
This service needs the special character device /dev/rtheap (10,254) when called from user-space tasks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The address of a queue descriptor Xenomai will use to store the queue-related data. This descriptor must always be valid while the message queue is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the queue. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created queue. Shared queues must be given a valid name.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poolsize</em>&nbsp;</td><td>The size (in bytes) of the message buffer pool which is going to be pre-allocated to the queue. Message buffers will be claimed and released to this pool. The buffer pool memory is not extensible, so this value must be compatible with the highest message pressure that could be expected.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qlimit</em>&nbsp;</td><td>This parameter allows to limit the maximum number of messages which can be queued at any point in time. Sending to a full queue begets an error. The special value Q_UNLIMITED can be passed to specify an unlimited amount.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The queue creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new queue:</td></tr>
  </table>
</dl>
<ul>
<li>Q_FIFO makes tasks pend in FIFO order on the queue for consuming messages.</li></ul>
<p>
<ul>
<li>Q_PRIO makes tasks pend in priority order on the queue.</li></ul>
<p>
<ul>
<li>Q_SHARED causes the queue to be sharable between kernel and user-space tasks. Otherwise, the new queue is only available for kernel-based usage. This flag is implicitely set when the caller is running in user-space. This feature requires the real-time support in user-space to be configured in (CONFIG_XENO_OPT_PERVASIVE).</li></ul>
<p>
<ul>
<li>Q_DMA causes the buffer pool associated to the queue to be allocated in physically contiguous memory, suitable for DMA operations with I/O devices. A 128Kb limit exists for <em>poolsize</em> when this flag is passed.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>poolsize</em> is null, greater than the system limit, or <em>name</em> is null or empty for a shared queue.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough system memory is available to create or register the queue. Additionally, and if Q_SHARED has been passed in <em>mode</em>, errors while mapping the buffer pool in the caller's address space might beget this return code too.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an invalid context.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if <em>mode</em> specifies Q_SHARED, but the real-time support in user-space is unavailable.</li></ul>
<p>
<ul>
<li>-ENOENT is returned if /dev/rtheap can't be opened.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gbc678dfb236b0dad434067496cead127"></a><!-- doxytag: member="queue.c::rt_queue_delete" ref="gbc678dfb236b0dad434067496cead127" args="(RT_QUEUE *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a message queue.<p>
Destroy a message queue and release all the tasks currently pending on it. A queue exists in the system since <a class="el" href="group__native__queue.html#gacad717bbd6d75338fada8f5b4a67b3f">rt_queue_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the affected queue.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if an attempt is made to delete a shared queue which is still bound to a process.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode).</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g40d16a5ab14ea033889bb839967204e4"></a><!-- doxytag: member="queue.c::rt_queue_free" ref="g40d16a5ab14ea033889bb839967204e4" args="(RT_QUEUE *q, void *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_free           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a message queue buffer.<p>
This service releases a message buffer returned by <a class="el" href="group__native__queue.html#g44759168a589ddbb2b60c1c1b183f448">rt_queue_receive()</a> to the queue's internal pool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the affected queue.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the message buffer to free. Even zero-sized messages carrying no payload data must be freed, since they are assigned a valid memory space to store internal information.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>buf</em> is not a valid message buffer previously allocated by the <a class="el" href="group__native__queue.html#g8eaee8ca7d0c3af801c4df6f0adae421">rt_queue_alloc()</a> service, or the caller did not get ownership of the message through a successful return from <a class="el" href="group__native__queue.html#g44759168a589ddbb2b60c1c1b183f448">rt_queue_receive()</a>.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g654017c0f87d8c23329aeefff93e6a70"></a><!-- doxytag: member="queue.c::rt_queue_inquire" ref="g654017c0f87d8c23329aeefff93e6a70" args="(RT_QUEUE *q, RT_QUEUE_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_QUEUE_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about a message queue.<p>
Return various information about the status of a given queue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the inquired queue.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the queue information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g4083beec0186ce66c66ee0d3fc1b5eee"></a><!-- doxytag: member="queue.c::rt_queue_read" ref="g4083beec0186ce66c66ee0d3fc1b5eee" args="(RT_QUEUE *q, void *buf, size_t size, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_read           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a message from a queue.<p>
This service retrieves the next message available from the given queue. Unless otherwise specified, the caller is blocked for a given amount of time if no message is immediately available on entry. This services differs from <a class="el" href="group__native__queue.html#g44759168a589ddbb2b60c1c1b183f448">rt_queue_receive()</a> in that it copies back the payload data to a user-defined memory area, instead of returning a pointer to the message buffer holding such data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the message queue to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A pointer to a memory area which will be written upon success with the message contents. The internal message buffer conveying the data is automatically freed by this call.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The length in bytes of the memory area pointed to by <em>buf</em>. Messages larger than <em>size</em> are truncated appropriately.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some message is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no message is available on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes available from the received message is returned upon success, which might be greater than the actual number of bytes copied to the destination buffer if the message has been truncated. Zero is a possible value corresponding to a zero-sized message passed to <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a> or <a class="el" href="group__native__queue.html#g9ef8d1826bb13fe706a4566890972657">rt_queue_write()</a>. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no message is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no message is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g44759168a589ddbb2b60c1c1b183f448"></a><!-- doxytag: member="queue.c::rt_queue_receive" ref="g44759168a589ddbb2b60c1c1b183f448" args="(RT_QUEUE *q, void **bufp, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_receive           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a message from a queue.<p>
This service retrieves the next message available from the given queue. Unless otherwise specified, the caller is blocked for a given amount of time if no message is immediately available on entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the message queue to receive from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the received message. Once consumed, the message space should be freed using <a class="el" href="group__native__queue.html#g40d16a5ab14ea033889bb839967204e4">rt_queue_free()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for some message to arrive (see note). Passing TM_INFINITE causes the caller to block indefinitely until some message is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no message is available on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes available from the received message is returned upon success. Zero is a possible value corresponding to a zero-sized message passed to <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a>. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no message is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no message is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before any data was available.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8b1dcb15753bdfce02f25f166e18948d"></a><!-- doxytag: member="queue.c::rt_queue_send" ref="g8b1dcb15753bdfce02f25f166e18948d" args="(RT_QUEUE *q, void *mbuf, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_send           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message to a queue.<p>
This service sends a complete message to a given queue. The message must have been allocated by a previous call to <a class="el" href="group__native__queue.html#g8eaee8ca7d0c3af801c4df6f0adae421">rt_queue_alloc()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the message queue to send to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mbuf</em>&nbsp;</td><td>The address of the message buffer to be sent. The message buffer must have been allocated using the <a class="el" href="group__native__queue.html#g8eaee8ca7d0c3af801c4df6f0adae421">rt_queue_alloc()</a> service. Once passed to <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a>, the memory pointed to by <em>mbuf</em> is no more under the control of the sender and thus should not be referenced by it anymore; deallocation of this memory must be handled on the receiving side.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message. Zero is a valid value, in which case an empty message will be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>Q_URGENT causes the message to be prepended to the message queue, ensuring a LIFO ordering.</li></ul>
<p>
<ul>
<li>Q_NORMAL causes the message to be appended to the message queue, ensuring a FIFO ordering.</li></ul>
<p>
<ul>
<li>Q_BROADCAST causes the message to be sent to all tasks currently waiting for messages. The message is not copied; a reference count is maintained instead so that the message will remain valid until the last receiver releases its own reference using <a class="el" href="group__native__queue.html#g40d16a5ab14ea033889bb839967204e4">rt_queue_free()</a>, after which the message space will be returned to the queue's internal pool.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Upon success, this service returns the number of receivers which got awaken as a result of the operation. If zero is returned, no task was waiting on the receiving side of the queue, and the message has been enqueued. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor, or <em>mbuf</em> is not a valid message buffer obtained from a previous call to <a class="el" href="group__native__queue.html#g8eaee8ca7d0c3af801c4df6f0adae421">rt_queue_alloc()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if queuing the message would exceed the limit defined for the queue at creation.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g1f190858ca18d906db339e086bfa8ced"></a><!-- doxytag: member="queue.c::rt_queue_unbind" ref="g1f190858ca18d906db339e086bfa8ced" args="(RT_QUEUE *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from a shared message queue.<p>
This user-space only service unbinds the calling task from the message queue object previously retrieved by a call to <a class="el" href="group__native__queue.html#g162bb372c5c3616666e8e1fbdcc79343">rt_queue_bind()</a>.<p>
Unbinding from a message queue when it is no more needed is especially important in order to properly release the mapping resources used to attach the shared queue memory to the caller's address space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The address of a queue descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is invalid or not bound.</li></ul>
<p>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="msg__queue_8c-example.html#a3">msg_queue.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g9ef8d1826bb13fe706a4566890972657"></a><!-- doxytag: member="queue.c::rt_queue_write" ref="g9ef8d1826bb13fe706a4566890972657" args="(RT_QUEUE *q, const void *buf, size_t size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_write           </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a message to a queue.<p>
This service writes a complete message to a given queue. This service differs from <a class="el" href="group__native__queue.html#g8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a> in that it accepts a pointer to the raw data to be sent, instead of a canned message buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>The descriptor address of the message queue to write to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The address of the message data to be written to the queue. A message buffer will be allocated internally to convey the data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the message data. Zero is a valid value, in which case an empty message will be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A set of flags affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>Q_URGENT causes the message to be prepended to the message queue, ensuring a LIFO ordering.</li></ul>
<p>
<ul>
<li>Q_NORMAL causes the message to be appended to the message queue, ensuring a FIFO ordering.</li></ul>
<p>
<ul>
<li>Q_BROADCAST causes the message to be sent to all tasks currently waiting for messages. The message is not copied; a reference count is maintained instead so that the message will remain valid until all receivers get a copy of the message, after which the message space will be returned to the queue's internal pool.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Upon success, this service returns the number of receivers which got awaken as a result of the operation. If zero is returned, no task was waiting on the receiving side of the queue, and the message has been enqueued. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>q</em> is a deleted queue descriptor.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if queuing the message would exceed the limit defined for the queue at creation, or if no memory can be obtained to convey the message data internally.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 11 12:33:53 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
