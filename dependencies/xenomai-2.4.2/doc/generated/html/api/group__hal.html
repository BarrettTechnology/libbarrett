<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: HAL.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>HAL.</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Generic Adeos-based hardware abstraction layer. 
<p>
x86_64-specific HAL services.<p>
i386-specific HAL services.<p>
PowerPC-specific HAL services.<p>
ia64-specific HAL services.<p>
Generic NMI watchdog services.<p>
Blackfin-specific HAL services.<p>
ARM-specific HAL services. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="arm_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for PowerPC. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for the Blackfin architecture. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="blackfin_2nmi_8c.html">nmi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NMI watchdog support. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic Real-Time HAL. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="generic_2nmi_8c.html">nmi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ia64_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for ia64. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="powerpc_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for PowerPC. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal-common_8c.html">hal-common.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__32_8c.html">hal_32.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__64_8c.html">hal_64.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adeos-based Real-Time Abstraction Layer for x86_64. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nmi__32_8c.html">nmi_32.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NMI watchdog for x86, from linux/arch/i386/kernel/nmi.c. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="smi_8c.html">smi.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SMI workaround for x86. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g1ff77e4ea7ed60ba6a1b1a61a513058d">rthal_timer_release</a> (int cpu)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ge84c63d8728c72e9374da3a86df14d64">rthal_irq_host_request</a> (unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g80403d346662fcc3c960f12e4d5b8e09">rthal_irq_host_release</a> (unsigned irq, void *dev_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable</a> (unsigned irq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g615e2795b5a080f9155bf2f9f29e0b3f">rthal_irq_disable</a> (unsigned irq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request</a> (unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gd7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release</a> (unsigned irq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g74372309e2009faaa4d6c1e56932e9b8">rthal_irq_host_pend</a> (unsigned irq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g63c5799998ae73a818b3c3be4cca89bd">rthal_irq_affinity</a> (unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">rthal_trap_handler_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g3f868180536815c231983781afef99c4">rthal_trap_catch</a> (rthal_trap_handler_t handler)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc</a> (const char *name, void(*handler)(void *cookie), void *cookie)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#gf11636f94b0a6913241679d84265eba6">rthal_apc_free</a> (int apc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga0e99241b9b16e6a43a4eb0ec144448e">rthal_apc_schedule</a> (int apc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#g174a498bd8ee10a2279a9f79b9823bf6">rthal_timer_request</a> (void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gfb91722da28118853a09b1a0d98dd169"></a><!-- doxytag: member="hal.c::rthal_apc_alloc" ref="gfb91722da28118853a09b1a0d98dd169" args="(const char *name, void(*handler)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_apc_alloc           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an APC slot.<p>
APC is the acronym for Asynchronous Procedure Call, a mean by which activities from the Xenomai domain can schedule deferred invocations of handlers to be run into the Linux domain, as soon as possible when the Linux kernel gets back in control. Up to BITS_PER_LONG APC slots can be active at any point in time. APC support is built upon Adeos's virtual interrupt support.<p>
The HAL guarantees that any Linux kernel service which would be callable from a regular Linux interrupt handler is also available to APC handlers, including over PREEMPT_RT kernels exhibiting a threaded IRQ model.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a symbolic name identifying the APC which will get reported through the /proc/xenomai/apc interface. Passing NULL to create an anonymous APC is allowed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handle will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the APC handler as its sole argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an valid APC id. is returned upon success, or a negative error code otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>handler</em> is invalid.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if no more APC slots are available.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="gf11636f94b0a6913241679d84265eba6"></a><!-- doxytag: member="hal.c::rthal_apc_free" ref="gf11636f94b0a6913241679d84265eba6" args="(int apc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_apc_free           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>apc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases an APC slot.<p>
This service deallocates an APC slot obtained by <a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apc</em>&nbsp;</td><td>The APC id. to release, as returned by a successful call to the <a class="el" href="group__hal.html#gfb91722da28118853a09b1a0d98dd169">rthal_apc_alloc()</a> service.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>apc</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="ga0e99241b9b16e6a43a4eb0ec144448e"></a><!-- doxytag: member="hal.c::rthal_apc_schedule" ref="ga0e99241b9b16e6a43a4eb0ec144448e" args="(int apc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_apc_schedule           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>apc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Schedule an APC invocation.<p>
This service marks the APC as pending for the Linux domain, so that its handler will be called as soon as possible, when the Linux domain gets back in control.<p>
When posted from the Linux domain, the APC handler is fired as soon as the interrupt mask is explicitly cleared by some kernel code. When posted from the Xenomai domain, the APC handler is fired as soon as the Linux domain is resumed, i.e. after Xenomai has completed all its pending duties.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>apc</em>&nbsp;</td><td>The APC id. to schedule.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>apc</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context, albeit the usual calling place is from the Xenomai domain. </li></ul>

</div>
</div><p>
<a class="anchor" name="g63c5799998ae73a818b3c3be4cca89bd"></a><!-- doxytag: member="hal.c::rthal_irq_affinity" ref="g63c5799998ae73a818b3c3be4cca89bd" args="(unsigned irq, cpumask_t cpumask, cpumask_t *oldmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_affinity           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t&nbsp;</td>
          <td class="paramname"> <em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t *&nbsp;</td>
          <td class="paramname"> <em>oldmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set/Get processor affinity for external interrupt.<p>
On SMP systems, this service ensures that the given interrupt is preferably dispatched to the specified set of processors. The previous affinity mask is returned by this service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source whose processor affinity is affected by the operation. Only external interrupts can have their affinity changed/queried, thus virtual interrupt numbers allocated by rthal_alloc_virq() are invalid values for this parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpumask</em>&nbsp;</td><td>A list of CPU identifiers passed as a bitmask representing the new affinity for this interrupt. A zero value cause this service to return the current affinity mask without changing it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldmask</em>&nbsp;</td><td>If non-NULL, a pointer to a memory area which will bve overwritten by the previous affinity mask used for this interrupt source, or a zeroed mask if an error occurred. This service always returns a zeroed mask on uniprocessor systems.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g615e2795b5a080f9155bf2f9f29e0b3f"></a><!-- doxytag: member="hal.c::rthal_irq_disable" ref="g615e2795b5a080f9155bf2f9f29e0b3f" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_disable           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable an interrupt source.<p>
Disables an interrupt source at PIC level. After this call has returned, no more IRQs from the given source will be allowed, until the latter is enabled again using <a class="el" href="group__hal.html#g306c0dcb88589f6a84f9b9d3304c4e8e">rthal_irq_enable()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to disable. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g306c0dcb88589f6a84f9b9d3304c4e8e"></a><!-- doxytag: member="hal.c::rthal_irq_enable" ref="g306c0dcb88589f6a84f9b9d3304c4e8e" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_enable           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable an interrupt source.<p>
Enables an interrupt source at PIC level. Since Adeos masks and acknowledges the associated interrupt source upon IRQ receipt, this action is usually needed whenever the HAL handler does not propagate the IRQ event to the Linux domain, thus preventing the regular Linux interrupt handling code from re-enabling said source. After this call has returned, IRQs from the given source will be enabled again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to enable. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g74372309e2009faaa4d6c1e56932e9b8"></a><!-- doxytag: member="hal.c::rthal_irq_host_pend" ref="g74372309e2009faaa4d6c1e56932e9b8" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_host_pend           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Propagate an IRQ event to Linux.<p>
Causes the given IRQ to be propagated down to the Adeos pipeline to the Linux kernel. This operation is typically used after the given IRQ has been processed into the Xenomai domain by a real-time interrupt handler (see <a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a>), in case such interrupt must also be handled by the Linux kernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Xenomai domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g80403d346662fcc3c960f12e4d5b8e09"></a><!-- doxytag: member="hal.c::rthal_irq_host_release" ref="g80403d346662fcc3c960f12e4d5b8e09" args="(unsigned irq, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_host_release           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uninstall a shared Linux interrupt handler.<p>
Uninstalls a shared interrupt handler from the Linux domain for the given interrupt source. The handler is removed from the existing list of Linux handlers for this interrupt source.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to detach the shared handler from. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is a valid device id, identical in essence to the one requested by the free_irq() service provided by the Linux kernel. This value will be used to locate the handler to remove from the chain of existing Linux handlers for the given interrupt source. This parameter must match the device id. passed to <a class="el" href="group__hal.html#ge84c63d8728c72e9374da3a86df14d64">rthal_irq_host_request()</a> for the same handler instance.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="ge84c63d8728c72e9374da3a86df14d64"></a><!-- doxytag: member="hal.c::rthal_irq_host_request" ref="ge84c63d8728c72e9374da3a86df14d64" args="(unsigned irq, rthal_irq_host_handler_t handler, char *name, void *dev_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_host_request           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_host_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Install a shared Linux interrupt handler.<p>
Installs a shared interrupt handler in the Linux domain for the given interrupt source. The handler is appended to the existing list of Linux handlers for this interrupt source.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The interrupt source to attach the shared handler to. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, as part of the chain of existing regular Linux handlers for this interrupt source. The handler prototype is the same as the one required by the request_irq() service provided by the Linux kernel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a symbolic name identifying the handler which will get reported through the /proc/interrupts interface.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is a unique device id, identical in essence to the one requested by the request_irq() service.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="gd7d90c5882463a1d36b7a0ad74a9d4ff"></a><!-- doxytag: member="hal.c::rthal_irq_release" ref="gd7d90c5882463a1d36b7a0ad74a9d4ff" args="(unsigned irq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_release           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uninstall a real-time interrupt handler.<p>
Uninstalls an interrupt handler previously attached using the <a class="el" href="group__hal.html#gadf0f98059a5bf1caddda9dd48d51f20">rthal_irq_request()</a> service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to uninstall a handler from. This value is architecture-dependent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="gadf0f98059a5bf1caddda9dd48d51f20"></a><!-- doxytag: member="hal.c::rthal_irq_request" ref="gadf0f98059a5bf1caddda9dd48d51f20" args="(unsigned irq, rthal_irq_handler_t handler, rthal_irq_ackfn_t ackfn, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_irq_request           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rthal_irq_ackfn_t&nbsp;</td>
          <td class="paramname"> <em>ackfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Install a real-time interrupt handler.<p>
Installs an interrupt handler for the specified IRQ line by requesting the appropriate Adeos virtualization service. The handler is invoked by Adeos on behalf of the Xenomai domain context. Once installed, the HAL interrupt handler will be called prior to the regular Linux handler for the same interrupt source.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel to install a handler on. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of a valid interrupt service routine. This handler will be called each time the corresponding IRQ is delivered, and will be passed the <em>cookie</em> value unmodified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ackfn</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the one provided by Adeos. Only very specific situations actually require to override the default Adeos setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>ackfn</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>ackfn</em> is NULL, the default Adeos routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the HAL will pass to the interrupt handler as its sole argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if an interrupt handler is already installed. <a class="el" href="group__hal.html#gd7d90c5882463a1d36b7a0ad74a9d4ff">rthal_irq_release()</a> must be issued first before a handler is installed anew.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid or <em>handler</em> is NULL.</li></ul>
<p>
<ul>
<li>Other error codes might be returned in case some internal error happens at the Adeos level. Such error might caused by conflicting Adeos requests made by third-party code.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g1ff77e4ea7ed60ba6a1b1a61a513058d"></a><!-- doxytag: member="hal.c::rthal_timer_release" ref="g1ff77e4ea7ed60ba6a1b1a61a513058d" args="(int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rthal_timer_release           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpu</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the hardware timer.<p>
Releases the hardware timer, thus reverting the effect of a previous call to rthal_timer_request(). In case the timer hardware is shared with Linux, a periodic setup suitable for the Linux kernel will be reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU number the timer was grabbed from.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g174a498bd8ee10a2279a9f79b9823bf6"></a><!-- doxytag: member="hal.c::rthal_timer_request" ref="g174a498bd8ee10a2279a9f79b9823bf6" args="(void(*tick_handler)(void), void(*mode_emul)(enum clock_event_mode mode, struct clock_event_device *cdev), int(*tick_emul)(unsigned long delay, struct clock_event_device *cdev), int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_timer_request           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>tick_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(enum clock_event_mode mode, struct clock_event_device *cdev)&nbsp;</td>
          <td class="paramname"> <em>mode_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(unsigned long delay, struct clock_event_device *cdev)&nbsp;</td>
          <td class="paramname"> <em>tick_emul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grab the hardware timer.<p>
rthal_timer_request() grabs and tunes the hardware timer in oneshot mode in order to clock the master time base.<p>
A user-defined routine is registered as the clock tick handler. This handler will always be invoked on behalf of the Xenomai domain for each incoming tick.<p>
Hooks for emulating oneshot mode for the tick device are accepted when CONFIG_GENERIC_CLOCKEVENTS is defined for the host kernel. Host tick emulation is a way to share the clockchip hardware between Linux and Xenomai, when the former provides support for oneshot timing (i.e. high resolution timers and no-HZ scheduler ticking).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tick_handler</em>&nbsp;</td><td>The address of the Xenomai tick handler which will process each incoming tick.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode_emul</em>&nbsp;</td><td>The optional address of a callback to be invoked upon mode switch of the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tick_emul</em>&nbsp;</td><td>The optional address of a callback to be invoked upon setup of the next shot date for the host tick device, notified by the Linux kernel. This parameter is only considered whenever CONFIG_GENERIC_CLOCKEVENTS is defined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU number to grab the timer from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a positive value is returned on success, representing the duration of a Linux periodic tick expressed as a count of nanoseconds; zero should be returned when the Linux kernel does not undergo periodic timing on the given CPU (e.g. oneshot mode). Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the hardware timer has already been grabbed. rthal_timer_request() must be issued before rthal_timer_request() is called again.</li></ul>
<p>
<ul>
<li>-ENODEV is returned if the hardware timer cannot be used. This situation may occur after the kernel disabled the timer due to invalid calibration results; in such a case, such hardware is unusable for any timing duties.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Linux domain context. </li></ul>

</div>
</div><p>
<a class="anchor" name="g3f868180536815c231983781afef99c4"></a><!-- doxytag: member="hal.c::rthal_trap_catch" ref="g3f868180536815c231983781afef99c4" args="(rthal_trap_handler_t handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rthal_trap_catch           </td>
          <td>(</td>
          <td class="paramtype">rthal_trap_handler_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Installs a fault handler.<p>
The HAL attempts to invoke a fault handler whenever an uncontrolled exception or fault is caught at machine level. This service allows to install a user-defined handler for such events.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the fault handler to call upon exception condition. The handler is passed the address of the low-level information block describing the fault as passed by Adeos. Its layout is implementation-dependent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The address of the fault handler previously installed.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Any domain context. </li></ul>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 11 12:33:53 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
