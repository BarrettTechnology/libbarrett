<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Mutex services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Mutex services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Mutex services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__posix__mutex.png" border="0" alt="" usemap="#group____posix____mutex_map">
<map name="group____posix____mutex_map">
<area shape="rect" href="group__posix.html" title="Xenomai POSIX skin is an implementation of a small subset of the Single Unix specification..." alt="" coords="7,5,100,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Mutex services. 
<p>
A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.<p>
A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread). A mutex can never be owned by two different threads simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.<p>
Before it can be used, a mutex has to be initialized with <a class="el" href="group__posix__mutex.html#ga69c678b71382d12a78e259d317355ee" title="Initialize a mutex.">pthread_mutex_init()</a>. An attribute object, which reference may be passed to this service, allows to select the features of the created mutex, namely its <em>type</em> (see <a class="el" href="group__posix__mutex.html#g8387c80e660e9426f801ac0217ecfae5" title="Set the mutex type attribute of a mutex attributes object.">pthread_mutexattr_settype()</a>), the priority <em>protocol</em> it uses (see <a class="el" href="group__posix__mutex.html#g9c67ad95bb6cc0fb38dcc87b441b16b4" title="Set the protocol attribute of a mutex attributes object.">pthread_mutexattr_setprotocol()</a>) and whether it may be shared between several processes (see <a class="el" href="group__posix__mutex.html#g73bd8697b91e0ee9a63c30052ac9f72f" title="Set the process-shared attribute of a mutex attributes object.">pthread_mutexattr_setpshared()</a>).<p>
By default, Xenomai POSIX skin mutexes are of the normal type, use no priority protocol and may not be shared between several processes.<p>
Note that only <a class="el" href="group__posix__mutex.html#ga69c678b71382d12a78e259d317355ee" title="Initialize a mutex.">pthread_mutex_init()</a> may be used to initialize a mutex, using the static initializer <em>PTHREAD_MUTEX_INITIALIZER</em> is not supported. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#ga69c678b71382d12a78e259d317355ee">pthread_mutex_init</a> (pthread_mutex_t *mx, const pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a mutex.  <a href="#ga69c678b71382d12a78e259d317355ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gf15961a63f3579e9d9d483f75774b236">pthread_mutex_destroy</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex.  <a href="#gf15961a63f3579e9d9d483f75774b236"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g0c5fc5aa313b1763b02ef94db2eedbce">pthread_mutex_trylock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock a mutex.  <a href="#g0c5fc5aa313b1763b02ef94db2eedbce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gd096bda953dee8da39fdd9bf941602e3">pthread_mutex_lock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a mutex.  <a href="#gd096bda953dee8da39fdd9bf941602e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gd46010cd8f6916ac4a6e735e7c3e6496">pthread_mutex_timedlock</a> (pthread_mutex_t *mx, const struct timespec *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt, during a bounded time, to lock a mutex.  <a href="#gd46010cd8f6916ac4a6e735e7c3e6496"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gb6fc0b5282dd100530311128e4f5ff19">pthread_mutex_unlock</a> (pthread_mutex_t *mx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="#gb6fc0b5282dd100530311128e4f5ff19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gf98f6b6c483077a39d1400b1de1577b8">pthread_mutexattr_init</a> (pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a mutex attributes object.  <a href="#gf98f6b6c483077a39d1400b1de1577b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g2321aabf58224b06021185708d0f9658">pthread_mutexattr_destroy</a> (pthread_mutexattr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex attributes object.  <a href="#g2321aabf58224b06021185708d0f9658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g7f064a4db96a009a5a9a7c7e5cc03599">pthread_mutexattr_gettype</a> (const pthread_mutexattr_t *attr, int *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutex type attribute from a mutex attributes object.  <a href="#g7f064a4db96a009a5a9a7c7e5cc03599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g8387c80e660e9426f801ac0217ecfae5">pthread_mutexattr_settype</a> (pthread_mutexattr_t *attr, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mutex type attribute of a mutex attributes object.  <a href="#g8387c80e660e9426f801ac0217ecfae5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g9c25f33bff14bc8cc01015cc4924051a">pthread_mutexattr_getprotocol</a> (const pthread_mutexattr_t *attr, int *proto)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the protocol attribute from a mutex attributes object.  <a href="#g9c25f33bff14bc8cc01015cc4924051a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g9c67ad95bb6cc0fb38dcc87b441b16b4">pthread_mutexattr_setprotocol</a> (pthread_mutexattr_t *attr, int proto)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the protocol attribute of a mutex attributes object.  <a href="#g9c67ad95bb6cc0fb38dcc87b441b16b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#gf8d7f85a0d52d3560db6d36cf9b44ac0">pthread_mutexattr_getpshared</a> (const pthread_mutexattr_t *attr, int *pshared)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the process-shared attribute of a mutex attributes object.  <a href="#gf8d7f85a0d52d3560db6d36cf9b44ac0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__mutex.html#g73bd8697b91e0ee9a63c30052ac9f72f">pthread_mutexattr_setpshared</a> (pthread_mutexattr_t *attr, int pshared)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the process-shared attribute of a mutex attributes object.  <a href="#g73bd8697b91e0ee9a63c30052ac9f72f"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf15961a63f3579e9d9d483f75774b236"></a><!-- doxytag: member="mutex.c::pthread_mutex_destroy" ref="gf15961a63f3579e9d9d483f75774b236" args="(pthread_mutex_t *mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_destroy           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a mutex. 
<p>
This service destroys the mutex <em>mx</em>, if it is unlocked and not referenced by any condition variable. The mutex becomes invalid for all mutex services (they all return the EINVAL error) except <a class="el" href="group__posix__mutex.html#ga69c678b71382d12a78e259d317355ee" title="Initialize a mutex.">pthread_mutex_init()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be destroyed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EPERM, the mutex is not process-shared and does not belong to the current process;</li><li>EBUSY, the mutex is locked, or used by a condition variable.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_destroy.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga69c678b71382d12a78e259d317355ee"></a><!-- doxytag: member="mutex.c::pthread_mutex_init" ref="ga69c678b71382d12a78e259d317355ee" args="(pthread_mutex_t *mx, const pthread_mutexattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_init           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a mutex. 
<p>
This services initializes the mutex <em>mx</em>, using the mutex attributes object <em>attr</em>. If <em>attr</em> is <em>NULL</em>, default attributes are used (see <a class="el" href="group__posix__mutex.html#gf98f6b6c483077a39d1400b1de1577b8" title="Initialize a mutex attributes object.">pthread_mutexattr_init()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be initialized;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the mutex attributes object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid or uninitialized;</li><li>EBUSY, the mutex <em>mx</em> was already initialized;</li><li>ENOMEM, insufficient memory exists in the system heap to initialize the mutex, increase CONFIG_XENO_OPT_SYS_HEAPSZ.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_init.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd096bda953dee8da39fdd9bf941602e3"></a><!-- doxytag: member="mutex.c::pthread_mutex_lock" ref="gd096bda953dee8da39fdd9bf941602e3" args="(pthread_mutex_t *mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_lock           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock a mutex. 
<p>
This service attempts to lock the mutex <em>mx</em>. If the mutex is free, it becomes locked. If it was locked by another thread than the current one, the current thread is suspended until the mutex is unlocked. If it was already locked by the current mutex, the behaviour of this service depends on the mutex type :<ul>
<li>for mutexes of the <em>PTHREAD_MUTEX_NORMAL</em> type, this service deadlocks;</li><li>for mutexes of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type, this service returns the EDEADLK error number;</li><li>for mutexes of the <em>PTHREAD_MUTEX_RECURSIVE</em> type, this service increments the lock recursion count and returns 0.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EPERM, the mutex is not process-shared and does not belong to the current process;</li><li>EDEADLK, the mutex is of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type and was already locked by the current thread;</li><li>EAGAIN, the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> type and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_lock.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd46010cd8f6916ac4a6e735e7c3e6496"></a><!-- doxytag: member="mutex.c::pthread_mutex_timedlock" ref="gd46010cd8f6916ac4a6e735e7c3e6496" args="(pthread_mutex_t *mx, const struct timespec *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_timedlock           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt, during a bounded time, to lock a mutex. 
<p>
This service is equivalent to <a class="el" href="group__posix__mutex.html#gd096bda953dee8da39fdd9bf941602e3" title="Lock a mutex.">pthread_mutex_lock()</a>, except that if the mutex <em>mx</em> is locked by another thread than the current one, this service only suspends the current thread until the timeout specified by <em>to</em> expires.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>the timeout, expressed as an absolute value of the CLOCK_REALTIME clock.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EPERM, the mutex is not process-shared and does not belong to the current process;</li><li>ETIMEDOUT, the mutex could not be locked and the specified timeout expired;</li><li>EDEADLK, the mutex is of the <em>PTHREAD_MUTEX_ERRORCHECK</em> type and the mutex was already locked by the current thread;</li><li>EAGAIN, the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> type and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_timedlock.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0c5fc5aa313b1763b02ef94db2eedbce"></a><!-- doxytag: member="mutex.c::pthread_mutex_trylock" ref="g0c5fc5aa313b1763b02ef94db2eedbce" args="(pthread_mutex_t *mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_trylock           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to lock a mutex. 
<p>
This service is equivalent to <a class="el" href="group__posix__mutex.html#gd096bda953dee8da39fdd9bf941602e3" title="Lock a mutex.">pthread_mutex_lock()</a>, except that if the mutex <em>mx</em> is locked by another thread than the current one, this service returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be locked.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex is invalid;</li><li>EPERM, the mutex is not process-shared and does not belong to the current process;</li><li>EBUSY, the mutex was locked by another thread than the current one;</li><li>EAGAIN, the mutex is recursive, and the maximum number of recursive locks has been exceeded.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_trylock.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb6fc0b5282dd100530311128e4f5ff19"></a><!-- doxytag: member="mutex.c::pthread_mutex_unlock" ref="gb6fc0b5282dd100530311128e4f5ff19" args="(pthread_mutex_t *mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutex_unlock           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock a mutex. 
<p>
This service unlocks the mutex <em>mx</em>. If the mutex is of the <em>PTHREAD_MUTEX_RECURSIVE</em> <em>type</em> and the locking recursion count is greater than one, the lock recursion count is decremented and the mutex remains locked.<p>
Attempting to unlock a mutex which is not locked or which is locked by another thread than the current one yields the EPERM error, whatever the mutex <em>type</em> attribute.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mx</em>&nbsp;</td><td>the mutex to be released.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the mutex <em>mx</em> is invalid;</li><li>EPERM, the mutex was not locked by the current thread.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>kernel-space cancellation cleanup routine,</li><li>Xenomai user-space thread (switches to primary mode),</li><li>user-space cancellation cleanup routine.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutex_unlock.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2321aabf58224b06021185708d0f9658"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_destroy" ref="g2321aabf58224b06021185708d0f9658" args="(pthread_mutexattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_destroy           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a mutex attributes object. 
<p>
This service destroys the mutex attributes object <em>attr</em>. The object becomes invalid for all mutex services (they all return EINVAL) except <a class="el" href="group__posix__mutex.html#gf98f6b6c483077a39d1400b1de1577b8" title="Initialize a mutex attributes object.">pthread_mutexattr_init()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the initialized mutex attributes object to be destroyed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_destroy.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9c25f33bff14bc8cc01015cc4924051a"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_getprotocol" ref="g9c25f33bff14bc8cc01015cc4924051a" args="(const pthread_mutexattr_t *attr, int *proto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_getprotocol           </td>
          <td>(</td>
          <td class="paramtype">const pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>proto</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the protocol attribute from a mutex attributes object. 
<p>
This service stores, at the address <em>proto</em>, the value of the <em>protocol</em> attribute in the mutex attributes object <em>attr</em>.<p>
The <em>protcol</em> attribute may only be one of <em>PTHREAD_PRIO_NONE</em> or <em>PTHREAD_PRIO_INHERIT</em>. See <a class="el" href="group__posix__mutex.html#g9c67ad95bb6cc0fb38dcc87b441b16b4" title="Set the protocol attribute of a mutex attributes object.">pthread_mutexattr_setprotocol()</a> for the meaning of these two constants.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proto</em>&nbsp;</td><td>address where the value of the <em>protocol</em> attribute will be stored on success.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the <em>proto</em> address is invalid;</li><li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_getprotocol.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf8d7f85a0d52d3560db6d36cf9b44ac0"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_getpshared" ref="gf8d7f85a0d52d3560db6d36cf9b44ac0" args="(const pthread_mutexattr_t *attr, int *pshared)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_getpshared           </td>
          <td>(</td>
          <td class="paramtype">const pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pshared</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the process-shared attribute of a mutex attributes object. 
<p>
This service stores, at the address <em>pshared</em>, the value of the <em>pshared</em> attribute in the mutex attributes object <em>attr</em>.<p>
The <em>pashared</em> attribute may only be one of <em>PTHREAD_PROCESS_PRIVATE</em> or <em>PTHREAD_PROCESS_SHARED</em>. See <a class="el" href="group__posix__mutex.html#g73bd8697b91e0ee9a63c30052ac9f72f" title="Set the process-shared attribute of a mutex attributes object.">pthread_mutexattr_setpshared()</a> for the meaning of these two constants.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pshared</em>&nbsp;</td><td>address where the value of the <em>pshared</em> attribute will be stored on success.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the <em>pshared</em> address is invalid;</li><li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_getpshared.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7f064a4db96a009a5a9a7c7e5cc03599"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_gettype" ref="g7f064a4db96a009a5a9a7c7e5cc03599" args="(const pthread_mutexattr_t *attr, int *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_gettype           </td>
          <td>(</td>
          <td class="paramtype">const pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutex type attribute from a mutex attributes object. 
<p>
This service stores, at the address <em>type</em>, the value of the <em>type</em> attribute in the mutex attributes object <em>attr</em>.<p>
See <a class="el" href="group__posix__mutex.html#gd096bda953dee8da39fdd9bf941602e3" title="Lock a mutex.">pthread_mutex_lock()</a> and <a class="el" href="group__posix__mutex.html#gb6fc0b5282dd100530311128e4f5ff19" title="Unlock a mutex.">pthread_mutex_unlock()</a> documentations for a description of the values of the <em>type</em> attribute and their effect on a mutex.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>address where the <em>type</em> attribute value will be stored on success.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on sucess, <p>
an error number if:<ul>
<li>EINVAL, the <em>type</em> address is invalid;</li><li>EINVAL, the mutex attributes object <em>attr</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_gettype.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf98f6b6c483077a39d1400b1de1577b8"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_init" ref="gf98f6b6c483077a39d1400b1de1577b8" args="(pthread_mutexattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_init           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a mutex attributes object. 
<p>
This services initializes the mutex attributes object <em>attr</em> with default values for all attributes. Default value are :<ul>
<li>for the <em>type</em> attribute, <em>PTHREAD_MUTEX_NORMAL</em>;</li><li>for the <em>protocol</em> attribute, <em>PTHREAD_PRIO_NONE</em>;</li><li>for the <em>pshared</em> attribute, <em>PTHREAD_PROCESS_PRIVATE</em>.</li></ul>
<p>
If this service is called specifying a mutex attributes object that was already initialized, the attributes object is reinitialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the mutex attributes object to be initialized.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ENOMEM, the mutex attributes object pointer <em>attr</em> is <em>NULL</em>.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_init.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9c67ad95bb6cc0fb38dcc87b441b16b4"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_setprotocol" ref="g9c67ad95bb6cc0fb38dcc87b441b16b4" args="(pthread_mutexattr_t *attr, int proto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_setprotocol           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>proto</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the protocol attribute of a mutex attributes object. 
<p>
This service set the <em>type</em> attribute of the mutex attributes object <em>attr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proto</em>&nbsp;</td><td>value of the <em>protocol</em> attribute, may be one of:<ul>
<li>PTHREAD_PRIO_NONE, meaning that a mutex created with the attributes object <em>attr</em> will not follow any priority protocol;</li><li>PTHREAD_PRIO_INHERIT, meaning that a mutex created with the attributes object <em>attr</em>, will follow the priority inheritance protocol.</li></ul>
</td></tr>
  </table>
</dl>
The value PTHREAD_PRIO_PROTECT (priority ceiling protocol) is unsupported.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid;</li><li>ENOTSUP, the value of <em>proto</em> is unsupported;</li><li>EINVAL, the value of <em>proto</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_setprotocol.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g73bd8697b91e0ee9a63c30052ac9f72f"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_setpshared" ref="g73bd8697b91e0ee9a63c30052ac9f72f" args="(pthread_mutexattr_t *attr, int pshared)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_setpshared           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pshared</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the process-shared attribute of a mutex attributes object. 
<p>
This service set the <em>pshared</em> attribute of the mutex attributes object <em>attr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pshared</em>&nbsp;</td><td>value of the <em>pshared</em> attribute, may be one of:<ul>
<li>PTHREAD_PROCESS_PRIVATE, meaning that a mutex created with the attributes object <em>attr</em> will only be accessible by threads within the same process as the thread that initialized the mutex;</li><li>PTHREAD_PROCESS_SHARED, meaning that a mutex created with the attributes object <em>attr</em> will be accessible by any thread that has access to the memory where the mutex is allocated.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error status if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid;</li><li>EINVAL, the value of <em>pshared</em> is invalid.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_setpshared.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8387c80e660e9426f801ac0217ecfae5"></a><!-- doxytag: member="mutex_attr.c::pthread_mutexattr_settype" ref="g8387c80e660e9426f801ac0217ecfae5" args="(pthread_mutexattr_t *attr, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_mutexattr_settype           </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the mutex type attribute of a mutex attributes object. 
<p>
This service set the <em>type</em> attribute of the mutex attributes object <em>attr</em>.<p>
See <a class="el" href="group__posix__mutex.html#gd096bda953dee8da39fdd9bf941602e3" title="Lock a mutex.">pthread_mutex_lock()</a> and <a class="el" href="group__posix__mutex.html#gb6fc0b5282dd100530311128e4f5ff19" title="Unlock a mutex.">pthread_mutex_unlock()</a> documentations for a description of the values of the <em>type</em> attribute and their effect on a mutex.<p>
The <em>PTHREAD_MUTEX_DEFAULT</em> default <em>type</em> is the same as <em>PTHREAD_MUTEX_NORMAL</em>. Note that using a Xenomai POSIX skin recursive mutex with a Xenomai POSIX skin condition variable is safe (see <a class="el" href="group__posix__cond.html#g03a32b6f066162e62f274dfcb58338eb" title="Wait on a condition variable.">pthread_cond_wait()</a> documentation).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>an initialized mutex attributes object,</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>value of the <em>type</em> attribute.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, <p>
an error number if:<ul>
<li>EINVAL, the mutex attributes object <em>attr</em> is invalid;</li><li>EINVAL, the value of <em>type</em> is invalid for the <em>type</em> attribute.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_mutexattr_settype.html">Specification.</a> </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 11 12:33:55 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
