<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Lightweight key-to-object mapping service</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Lightweight key-to-object mapping service<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Lightweight key-to-object mapping service:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__map.png" border="0" alt="" usemap="#group____map_map">
<map name="group____map_map">
<area shape="rect" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="5,5,139,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A map is a simple indexing structure which associates unique integer keys with pointers to objects. The current implementation supports reservation, for naming/indexing the real-time objects skins create, either on a fixed, user-provided integer (i.e. a reserved key value), or by drawing the next available key internally if the caller did not specify any fixed key. For instance, in some given map, the key space ranging from 0 to 255 could be reserved for fixed keys, whilst the range from 256 to 511 could be available for drawing free keys dynamically.<p>
A maximum of 1024 unique keys per map is supported on 32bit machines.<p>
(This implementation should not be confused with C++ STL maps, which are dynamically expandable and allow arbitrary key types; Xenomai maps don't). 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="map_8h.html">map.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="note" compact><dt><b>Note:</b></dt><dd>Copyright (C) 2007 Philippe Gerum &lt;<a href="mailto:rpm@xenomai.org">rpm@xenomai.org</a>&gt;. </dd></dl>
<br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="map_8c.html">map.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="note" compact><dt><b>Note:</b></dt><dd>Copyright (C) 2007 Philippe Gerum &lt;<a href="mailto:rpm@xenomai.org">rpm@xenomai.org</a>&gt;. </dd></dl>
<br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnmap_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__map.html#g011ef197e2f81ad708858902787f04f8">xnmap_create</a> (int nkeys, int reserve, int offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a map.  <a href="#g011ef197e2f81ad708858902787f04f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__map.html#g1a5b1c7a8e7966a2dd58404a0385aca8">xnmap_delete</a> (xnmap_t *map)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a map.  <a href="#g1a5b1c7a8e7966a2dd58404a0385aca8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__map.html#gdc5657b93b294c935ac6864fac5fdaa4">xnmap_enter</a> (xnmap_t *map, int key, void *objaddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index an object into a map.  <a href="#gdc5657b93b294c935ac6864fac5fdaa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__map.html#g06ec1012c075be6dbbadd2d88220abf5">xnmap_remove</a> (xnmap_t *map, int key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an object reference from a map.  <a href="#g06ec1012c075be6dbbadd2d88220abf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__map.html#g283c9dc07d28afa30ab42c833d432a38">xnmap_fetch</a> (xnmap_t *map, int key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search an object into a map.  <a href="#g283c9dc07d28afa30ab42c833d432a38"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g011ef197e2f81ad708858902787f04f8"></a><!-- doxytag: member="map.h::xnmap_create" ref="g011ef197e2f81ad708858902787f04f8" args="(int nkeys, int reserve, int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnmap_t * xnmap_create           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a map. 
<p>
Allocates a new map with the specified addressing capabilities. The memory is obtained from the Xenomai system heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nkeys</em>&nbsp;</td><td>The maximum number of unique keys the map will be able to hold. This value cannot exceed the static limit represented by XNMAP_MAX_KEYS, and must be a power of two.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reserve</em>&nbsp;</td><td>The number of keys which should be kept for reservation within the index space. Reserving a key means to specify a valid key to the <a class="el" href="group__map.html#gdc5657b93b294c935ac6864fac5fdaa4" title="Index an object into a map.">xnmap_enter()</a> service, which will then attempt to register this exact key, instead of drawing the next available key from the unreserved index space. When reservation is in effect, the unreserved index space will hold key values greater than <em>reserve</em>, keeping the low key values for the reserved space. For instance, passing <em>reserve</em> = 32 would cause the index range [ 0 .. 31 ] to be kept for reserved keys. When non-zero, <em>reserve</em> is rounded to the next multiple of BITS_PER_LONG. If <em>reserve</em> is zero no reservation will be available from the map.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The lowest key value <a class="el" href="group__map.html#gdc5657b93b294c935ac6864fac5fdaa4" title="Index an object into a map.">xnmap_enter()</a> will return to the caller. Key values will be in the range [ 0 + offset .. <em>nkeys</em> + offset - 1 ]. Negative offsets are valid.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the address of the new map is returned on success; otherwise, NULL is returned if <em>nkeys</em> is invalid.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g1a5b1c7a8e7966a2dd58404a0385aca8"></a><!-- doxytag: member="map.h::xnmap_delete" ref="g1a5b1c7a8e7966a2dd58404a0385aca8" args="(xnmap_t *map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnmap_delete           </td>
          <td>(</td>
          <td class="paramtype">xnmap_t *&nbsp;</td>
          <td class="paramname"> <em>map</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a map. 
<p>
Deletes a map, freeing any associated memory back to the Xenomai system heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>The address of the map to delete.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gdc5657b93b294c935ac6864fac5fdaa4"></a><!-- doxytag: member="map.h::xnmap_enter" ref="gdc5657b93b294c935ac6864fac5fdaa4" args="(xnmap_t *map, int key, void *objaddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnmap_enter           </td>
          <td>(</td>
          <td class="paramtype">xnmap_t *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>objaddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index an object into a map. 
<p>
Insert a new object into the given map.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>The address of the map to insert into.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to index the object on. If this key is within the valid index range [ 0 - offset .. nkeys - offset - 1 ], then an attempt to reserve this exact key is made. If <em>key</em> has an out-of-range value lower or equal to 0 - offset - 1, then an attempt is made to draw a free key from the unreserved index space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objaddr</em>&nbsp;</td><td>The address of the object to index on the key. This value will be returned by a successful call to <a class="el" href="group__map.html#g283c9dc07d28afa30ab42c833d432a38" title="Search an object into a map.">xnmap_fetch()</a> with the same key.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a valid key is returned on success, either <em>key</em> if reserved, or the next free key. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned upon attempt to reserve a busy key.</li></ul>
<p>
<ul>
<li>-ENOSPC when no more free key is available.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g283c9dc07d28afa30ab42c833d432a38"></a><!-- doxytag: member="map.h::xnmap_fetch" ref="g283c9dc07d28afa30ab42c833d432a38" args="(xnmap_t *map, int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * xnmap_fetch           </td>
          <td>(</td>
          <td class="paramtype">xnmap_t *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search an object into a map. 
<p>
Retrieve an object reference from the given map by its index key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>The address of the map to retrieve from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to be searched for in the map index.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The indexed object address is returned on success, otherwise NULL is returned when <em>key</em> is invalid or no object is currently indexed on it.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g06ec1012c075be6dbbadd2d88220abf5"></a><!-- doxytag: member="map.h::xnmap_remove" ref="g06ec1012c075be6dbbadd2d88220abf5" args="(xnmap_t *map, int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnmap_remove           </td>
          <td>(</td>
          <td class="paramtype">xnmap_t *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an object reference from a map. 
<p>
Removes an object reference from the given map, releasing the associated key.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>The address of the map to remove from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key the object reference to be removed is indexed on.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ESRCH is returned if <em>key</em> is invalid.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 11 12:33:52 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
